<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Game Analitics</title>

		<meta name="description" content="Game Analitics">
		<meta name="author" content="Moritz Wundke ">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/default.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Gamepolis 2013</h1>
					<h3>Game Analitics</h3>
					<p>
						<small>Moritz Wundke - Lead Programmer <a href="http://www.tragnarion.com/" target="_blank">Tragnarion Studios</a></small>
					</p>
				</section>

				<section>
					<h2>Game Analitics</h2>
					<ul>
						<li>Introducción</li>
						<li>Definiciones</li>
						<li>Análisis de datos</li>
						<li>Do it yourself</li>
					</ul>

					<aside class="notes">
						Just talk about what exactly we want to achieve
					</aside>
				</section>

				<section>
					<section>
						<h1>Introducción</h1>
						<ul>
							<li>La industria de los videojuegos esta creciendo a ritmos que nunca se han visto.</li>
							<li>Más de 60 mil millones de US$ en 2011 y unos 80 mil millones en 2012 según Colin Sebastian (RW Baird)</li>
							<li>Las inversiones aumentan y por lo tanto el riesgo</li>
							<li>Jugadores más exigentes</li>
						</ul>

						<aside class="notes">
							The industry has experienced an unprecedented growth. Social games, F2P, MMOs, ...
						</aside>
					</section>

					<section>
						<h2>Dominios</h2>
						<p>
							Podemos clasificar las necidades de análisis de un juego en tres puntos de vista differentes:
						</p>
					    <p class="fragment roll-in">Punto de vista de PRODUCTO</p>
					    <p class="fragment roll-in">Punto de vista de PROYECTO</p>
					    <p class="fragment roll-in">Punto de vista de RENDIMIENTO</p>
						<aside class="notes">
							The game must be viewed from different points in its life-cycle.
						</aside>
					</section>

					<section>
						<h2>Dominios</h2>
						<h3>PRODUCTO</h3>
						<p>
							Una vez que tengamos un <i>producto</i> tenemos que conocer su estado durante su cíclo de vida.
						</p>
						<ul>
							<li>¿El producto funciona?</li>
							<li>¿La experiencia de usario (UX) es la esperada?</li>
							<li>¿El contenido descargable tiene impacto?</li>
							<li>¿Dóndo fallamos?</li>
						</ul>
						<aside class="notes">
							What happens when the product is shipped. Is it working? Are our expansions working? Where do we fail?
						</aside>
					</section>

					<section>
						<h2>Dominios</h2>
						<h3>PROYECTO</h3>
						<p>
							Durante el desarollo del <i>proyecto</i> es muy importante saber que hacemos mal y también que hacemos bien.
						</p>
						<ul>
							<li>¿El juego es balanceado?</li>
							<li>¿Conseguiremos la duración deseasda?</li>
							<li>¿El diseño de los niveles se ajusta a lo esperado?</li>
						</ul>
						<aside class="notes">
							What happens when the product is shipped. Is it working? Are our expansions working? Where do we fail?
						</aside>
					</section>

					<section>
						<h2>Dominios</h2>
						<h3>RENDIMIENTO</h3>
						<p>
							Desde el punto de vista del <i>rendimiento</i> nos concentramos en la estabilidad y los aspectos técnicos del juego.
						</p>
						<ul>
							<li>¿Es estable?</li>
							<li>¿El rendimiento es acceptable?</li>
							<li>¿Dónde y porqué falla el rendimiento?</li>
						</ul>
						<aside class="notes">
							What happens when the product is shipped. Is it working? Are our expansions working? Where do we fail?
						</aside>
					</section>

					<section>
						<h2>¿Sistema propio?</h2>
						<p>
							El eterno dilema XD. Vamos a ver un poco en detalle los pros y los cons de hacer nuestro propio sistema.
						</p>
						<p>
							También es posible usar un sistema comercial ya existente. Tales como:
						</p>
						<ul>
							<li>MyGameHud (<a href="http://www.mygamehud.com">link</a>)</li>
							<li>playtomic (<a href="http://playtomic.org/">link</a>)</li>
							<li>Pingflux (<a href="http://www.pingflux.com/">link</a>)</li>
							<li>GameAnalitics (<a href="http://www.gameanalytics.com/">link</a>)</li>
						</ul>
						<aside class="notes">
							Talk about why it's a good idea to do it yourself if you have the resources (programmers...).

							Why does it seam cheaper at the beginning? OpenShift for example!
						</aside>
					</section>

					<section>
						<h2>¿Sistema propio?</h2>
						<p>
							Pero bueno, ¿aquí no estabamos para hacerlo nosotros mismos? Pues sí :D
						</p>
						<h3 class="fragment roll-in">PROS</h3>
						<ul class="fragment roll-in">
							<li>A nuestro gusto y necesidades</li>
							<li>Acceso directo a los datos</li>
							<li>Son tu datos, puedes usar las herramientas y métodos que quieras</li>
							<li>La verdad es que mola hacerlo!</li>
						</ul>
						<aside class="notes">
							Talk about why it's a good idea to do it yourself if you have the resources (programmers...).

							Why does it seam cheaper at the beginning? OpenShift for example!
						</aside>
					</section>

					<section>
						<h2>¿Sistema propio?</h2>
						<p>
							Todo tiene su lado malo, en este caso es solo algo gris ya que tampoco es para tanto XD.
						</p>
						<h3 class="fragment roll-in">CONS</h3>
						<ul class="fragment roll-in">
							<li>Recursos humanos especializados!</li>
							<li>No es 'Plug'n Play'</li>
							<li>Inversión inicial más elevada.</li>
						</ul>
						<aside class="notes">
							Talk about why it's a good idea to do it yourself if you have the resources (programmers...).

							Why does it seam cheaper at the beginning? OpenShift for example!
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Definiciones</h1>
						<p>
							Cuando creamos un sistema de análisis tenemos que tener conocer las cuatro definiciones básicas:
						</p>
						<ul class="fragment roll-in">
							<li>Analítica</li>
							<li>Telemetría</li>
							<li>Métrica</li>
							<li>Monetización</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Analítica</h2>

						<p>
							El proceso de descubrir y comunicar patrones en los datos que nos ayuden resolver problemas de negocio.
						</p>

						<ul class="fragment roll-in">
							<li>Dar soporte a las deciciones de negocio</li>
							<li>Conducir la toma de decisiones</li>
							<li>Mejorar el conocimiento que tengamos del proyecto/producto</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Telemetría</h2>

						<p>
							El proceso de captura de datos en un sistema y el posterior envio hacia otro.
						</p>

						<ul class="fragment roll-in">
							<li>Los datos en formato RAW sin procesar</li>
							<li>Describe en detalla a acciones, eventos, objectos, etc...</li>
							<li>Proviene de multitud de fuentes: tests, clientes, servidores, etc...</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Métrica</h2>

						<p>
							En matemáticas se define la métrica como la distancia entre elementos en un espacio. En nuestro caso sería una medida quantitativa e interpretable de los atributos de uno o más objetos en un contexto conocido.
						</p>

						<ul class="fragment roll-in">
							<li>Contexto, por ejemplo, usarios del juego, rendimiento, etc..</li>
							<li>Objetos como items, jugadores, usuarios, etc...</li>
							<li>Atributos de cada objecto, por ejemplo, el número de items de un jugador, etc...</li>
						</ul>


						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Monetización</h2>

						<p>
							La monetización es el proceso de convertir un producto en dinero. En el caso de los juegos es un pilar sumamente importante.
						</p>

						<ul class="fragment roll-in">
							<li>Clicks vs beneficios</li>
							<li>Cuantás descargas generamos</li>
							<li>El impacto de la publicidad, negativo y positivo</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h1>Análisi de datos</h1>
						<ul>
							<li>Normalización y estandarización</li>
							<li>Recomendadores y agrupamiento</li>
							<li>Extracción y seleción de datos</li>
							<li>Clasificación</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Normalización</h2>
						<p>
							La normalización de datos el proceso de procesar los datos RAW a algo que este dentro de nuestro rango de conocimiento.
						</p>
						<ul class="fragment roll-in">
							<li>Clampear valores</li>
							<li>Valores corruptos o ausentes
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Normalización</h2>
						<h3>Valores corruptos o ausentes</h3>
						<p>
							Cuando detectamos valores corruptos o ausentes tenemos que tomar ciertas medidas. <a href="http://www.utexas.edu/cola/centers/prc/_files/cs/Missing-Data.pdf">Melissa Humphries de la universidad de Texas</a> nos proporciona un buen estudio sobre ello.
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Normalización</h2>
						<h3>Pair wise deletion</h3>
						<p>
							Simplemente eliminamos los datos inválidos.
						</p>

						<ul>
							<li>
								Ventajas
								<ul>
									<li>Mantenemos todos los datos posibles</li>
									<li>El análisis tendrá toda la información disponible</li>
								</ul>
							</li>
							<li>
								Desventajas
								<ul>
									<li>El análisis no es comparable con otros</li>
									<li>Incluso la comparación entre atributos puede verse afectada</li>
								</ul>
							</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Normalización</h2>
						<h3>Pair wise deletion</h3>
						<p>
							Ejemplo:
						</p>

						<p>
							<img src="img/pairwise.png" height="450px"/>
						</p>
						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Normalización</h2>
						<h3>List wise deletion</h3>
						<p>
							La eliminación en lista consiste en eliminar la fila entera si almenos un atributo de ella es considerado inválido.
						</p>

						<ul>
							<li>
								Ventajas
								<ul>
									<li>Muy simple</li>
									<li>Comparable entre differentes análisis</li>
								</ul>
							</li>
							<li>
								Desventajas
								<ul>
									<li>Pierde validez estadística</li>
									<li>No usa toda la información disponible</li>
									<li>Estimaciones pueden ser sesgadas por la pérdida de datos</datos>
								</ul>
							</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Normalización</h2>
						<h3>List wise deletion</h3>
						<p>
							Ejemplo:
						</p>

						<p>
							<img src="img/listwise.png" height="450px"/>
						</p>
						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Normalización</h2>
						<h3>Sustitución por la media o la moda</h3>
						<p>
							Reemplazamos valores inválidos de la columna de atributos por la moda o la media.
						</p>

    <pre><code data-trim>
from collections import Counter
def mode_missing(l):
    """
    Substitude missing values '?' using the mode of the set
    """
    cl = Counter([l[i] for i in range(len(l)) if (l[i] != '?')])
    moda = float(cl.most_common()[0][0])
    return list(map(lambda x: moda if x=='?' else float(x), l))

from numpy import average
def mean_missing(l):
    """
    Substitude missing values '?' using the mean of the set
    """
    mean = average([l[i] for i in range(len(l)) if (l[i] != '?')])
    return list(map(lambda x: mean if x=='?' else float(x), l))
    </code></pre>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Estandarización</h2>
						<p>
							Cuando analizamos differentes datos a menudo intentamos comparar peras con manzanas, o almenos encontrar una relación entre sus atributos.
						</p>
						<p>
							Con una matríz de atributos ajustaremos cada columna para que puedan ser comparada con otra.
						</p>
    <pre><code data-trim>
from numpy import average, std
def standardize_matrix(m):
    """
    Standardize each colum of the matrix 'm'
    """
    averages = list(map(average, m))
    stds = list(map(std, m))

    return [list(map(lambda x: x if stds[i] == 0.0 else 
    	(x - averages[i]) / stds[i], m[i]))
        for i in range(len(m))]
    </code></pre>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Recomendadores y agrupamiento</h2>
						<p>
							Los recomendadores intentan proporcionar una recomendación fiable para un usario. En un análisis lo podemos ver como una predicción de usario que nos puede indicar mucha información útil.
						</p>
						<p>
							Los agrupadores intentan crear grupos de elementos pero respetándo cierta similitud entre los elementos de cada grupo.
						</p>
						<p>
							En ambos casos es necesario definir esa similitud entre elementos. Los métodos de similitud más comunes son la <b>distancia euclideana</b> y el <b>coeficiente de Pearson</b>.
						</p>

						<aside class="notes">
							Now start with the real stuff! 
						</aside>
					</section>

					<section>
						<h2>Recomendadores y agrupamiento</h2>
						<h3>Distancia euclidiana</h3>
						<p>
							También conocido como la generailzación a n dimensiones del teorema de Pitágoras. útil para valores lineales.
						</p>
						<p>
							Tiene problemas con valores extremos pero es barato por lo que se muy usado. Si sólo comparamos distancias podemos obviar la raíz quadrada.
						</p>
						<p>
							la distancia euclidiana entre dos puntos <i>P = (p<sub>1</sub>,p<sub>2</sub>,...,p<sub>n</sub>)</i> y <i>Q = (q<sub>1</sub>,2<sub>1</sub>,...,q<sub>n</sub>)</i> en un espacio de dimensión n &#8477;<sup>n</sup>.
						</p>

						<p>
							<img src="img/eucli.png" height="150px"/>
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Recomendadores y agrupamiento</h2>
						<h3>Distancia euclidiana</h3>

						<p>
							La operación extra para la similitud nos resuelve cualquier posible división por cero.
						</p>

    <pre><code data-trim>
def euclidean_dist(dic1, dic2):
    """Compute the sum of squares of the elements common
    to both dictionaries"""
    return sqrt(sum([pow(dic1[elem]-dic2[elem], 2)
                for elem in dic1 if elem in dic2]))

def euclidean_similarity(dic1, dic2):
    """Calculate the euclidean similarity."""
    return 1/(1+euclidean_dist(dic1, dic2))
    </code></pre>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Recomendadores y agrupamiento</h2>
						<h3>Coeficiente de Pearson</h3>

						<p>
							Resuelve los problemas de la distancia euclidiana con los valores extremos ya que computa correlaciones entre todo los elementos usando medias.
						</p>

						<p>
							<img src="img/pearson.png" height="150px"/>
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Recomendadores y agrupamiento</h2>
						<h3>Coeficiente de Pearson</h3>
						<p>
							EL coeficinete de Pearson tiene un rango de [-1,1] el cual nos indica la correlación entre las variables.
						</p>
						<ul>
							<li><b>1:</b> Las variables son perfectamente correlativas</li>
							<li><b>0:</b> No existe correlación entre ellas</li>
							<li><b>-1:</b> Las variables son negativamente correlativas o opuestas</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Recomendadores y agrupamiento</h2>
						<h3>Coeficiente de Pearson</h3>

    <pre><code data-trim>
def pearson_coeff(dic1, dic2):
    """Retrieve the elements common to both dictionaries"""
    commons  = [x for x in dic1 if x in dic2]
    nCommons = float(len(commons))

    # If there are no common elements, return zero; otherwise
    # compute the coefficient
    if nCommons==0:
        return 0

    # Compute the means of each dictionary
    mean1 = sum([dic1[x] for x in commons])/nCommons
    mean2 = sum([dic2[x] for x in commons])/nCommons

    # Compute numerator and denominator
    num  = sum([(dic1[x]-mean1)*(dic2[x]-mean2) for x in commons])
    den1 = sqrt(sum([pow(dic1[x]-mean1, 2) for x in commons]))
    den2 = sqrt(sum([pow(dic2[x]-mean2, 2) for x in commons]))
    den  = den1*den2

    # Compute the coefficient if possible or return zero
    if den==0:
        return 0

    return num/den
    </code></pre>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Recomendadores y agrupamiento</h2>
						<h3>Ponderado</h3>

						<p>
							Un recomendador ponderado se basa en similitudes considerados pesos.
						</p>

						<pre><code data-trim>def weightedRating(dictio, item, similarity = pearson_coeff):
    simils = {x: similarity(dictio[user], dictio[x], term)
              for x in dictio if x != user}
    numerator   = {}
    denominator = {}

    # The ratings dictionary is traversed, while filling the
    # auxiliary dictionaries with the values found.
    for id1 in simils:
        for id2 in dictio[id1]:
            if not numerator.has_key(id2):
                numerator  [id2] = []
                denominator[id2] = []
            s = simils[id1]
            numerator  [id1].append(dictio[id1][id2])
            denominator[id1].append(s)

    # Compute and sort weighted ratings    
    result = []
    for id2 in numerator:
        s1 = sum(numerator  [id2])
        s2 = sum(denominator[id2])
        if s2 == 0:
            mean = 0.0
        else:
            mean = s1/s2
        result.append((id2,mean))

    result.sort(key = lambda x: x[1], reverse=True)
    return result
    </code></pre>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Recomendadores y agrupamiento</h2>
						<h3>k-means</h3>

						<p>
							El algoritmo de k-means busca particiones de datos tales que cada punto este asignado a un centro llamado centroide del grupo. 
						</p>
						<ol>
							<li>Selecionar <i>k</i> puntos al azar como centroides iniciales.</li>
							<li>Asignar cada dato al centroide más cercano</li>
							<li>Recalcular los centroides de los <i>k</i> grupos para que sean el centro geométrico del grupo</li>
							<li>Volver al paso dos hasta que los grupos no varían</li>
						</ol>

						<aside class="notes">
							El centroide no ha de ser necesariamente un punto del gruopo
						</aside>
					</section>

					<section>
						<h2>Extracción y seleción de datos</h2>
						<p>
							La regla es simple: <b>datos = señal + ruido</b>
						</p>
						<p>
							Tampoco todos los datos son necesarios y a veces no nos dejan ver la realidad.
						</p>
						<p>
							Se conoce como <b>reducción de la dimensionalidad</b>
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Extracción y seleción de datos</h2>
						<h3>PCA</h3>
						<p>
							Princiapl Component Analysis
						</p>
						<ul>
							<li>Encuentra los ejes que forman la base de la nuve de puntos de datos. Sería como la fusión de los atributos.</li>
							<li>Consiste en la diagonalización de la matriz de la covarianza.</li>
							<li>En corto, nos indica que componenets influyen más.</li>
							<li>Representación visual en 2D o 3D.</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Extracción y seleción de datos</h2>
						<h3>PCA</h3>
						<p>
							Princiapl Component Analysis
						</p>
						<ol>
							<li>Calcular la matriz de covarianza</li>
							<li>Obtener los valores y vectores propios (base)</li>
							<li>Encontrar los valores y vectores relevantes</li>
							<li>Indica cuántos componentes son necesarios para obtener una vaianza X</li>
							<li>La suma de los valores propios nos da 1</li>
						</ol>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Extracción y seleción de datos</h2>
						<h3>PCA</h3>
						<p>
							<img src="img/pca_1.JPG" width="400"/>
							<img src="img/pca_2.JPG" width="400"/>
						</p>

						<aside class="notes">
							Imagen 1 Plot de valores propios y imagen 2 plot en 3d
						</aside>
					</section>

					<section>
						<h2>Extracción y seleción de datos</h2>
						<h3>LDA</h3>
						<p>
							Lineal Discrimination Analysis
						</p>
						<ul>
							<li>Analiza la dependencia lineal entre variables</li>
							<li>Produce una predicción</li>
							<li>Se considera machine learning</li>
							<li>Se usa en set de datos conocido de entrenamiento para predecir el resultado de un set desconocido</li>
							<li>Basado en estimaciones estadísticas</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Extracción y seleción de datos</h2>
						<h3>LDA</h3>
						<p>
							<img src="img/lda_1.JPG" width="400"/>
							<img src="img/lda_2.JPG" width="400"/>
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Extracción y seleción de datos</h2>
						<h3>MDS</h3>
						<p>
							Multi Dimensional Scaling
						</p>

						<p>
							Busca un espacio de dimensión reducida donde las distancias relativas entre los elementos se mantengan.
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Extracción y seleción de datos</h2>
						<h3>MDS</h3>
						<ol>
							<li>Crear una matríz de distancias MxM donde M representan las observaciones</li>
							<li>Crea una distribución aleatoria al espacio deseado (2D por ejemplo) de M</li>
							<li>Paa cada par de la distribución aleatoria se calcula la distancia entre el espacio proyectado (2D por ejemplo) y el original</li>
							<li>
								<ol>
									<li>Corregir la el error entre el espacio aleatorio y el original</li>
									<li>Si el erroro es mayorel random actual (sin corregir) es la solución.</li>
									<li>Sino corregir el error y volver al paso 3.1</li>
								</ol>
							</li>
						</ol>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Extracción y seleción de datos</h2>
						<h3>MDS</h3>
						<p>
							Las muertes (azul) están estrechamente relacionadas con las variables analizadas pero los kills (rojo) no.
						</p>
						<p>
							<img src="img/mds.JPG" width="500"/>
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Clasificación</h2>
						<p>
							Principalmente consiste en reconocer patrones y poner etiquetas a cada individuo a partir de ciertas propiedades que lo identifiquen.
						</p>
						<p>
							En juegos los clasificadores se suelen usar para identificar jugadores hard-core, casuales, etc...
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Clasificación</h2>
						<h3>kNN</h3>
						<p>
							k-Nearets-Neighbours
						</p>
						<p>
							Consiste en clasificar un elemento contanto los k vecinos más cercanos.
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Clasificación</h2>
						<h3>kNN</h3>
						<ul>
							<li><b>k=3:</b> El círculo rojo se clasifica como un rombo</li>
							<li><b>k=5:</b> El círuclo rojo se clasifica como un cuadrado</li>
						</ul>
						<p>
							<img src="img/knn.JPG" width="500"/>
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Clasificación</h2>
						<h3>Test estadístico</h3>
						<p>
							Es la diferenia estadística de los datos classificao significativa?
						</p>
						<ul>
							<li>Student</li>
							<li>McNemar, muy usado ya que es muy ligero</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>Clasificación</h2>
						<h3>McNemar</h3>
						<p>
							Dos implementaciones del test de McNemar. Personalmente prefiere la implementación que se encuentra en Wikipeda.
						</p>
						
						<pre><code data-trim>import collections
compare = lambda x, y: collections.Counter(x) == collections.Counter(y)

def McNemar(predF, predG, classes):
    if compare(predF, predG):
        return False

    f = predF != classes
    g = predG == classes
    A = float(sum(map(lambda x, y: x and y, f, g)))
    f = predG != classes
    g = predF == classes
    B = float(sum(map(lambda x, y: x and y, f, g)))

    t = (abs(A - B) - 1) ** 2 / (A + B)
    return t > 3.842

def McNemarWikipedia(predF, predG, classes):
    if compare(predF, predG):
        return False
        
    b = float(len(list(filter(lambda x: (predG[x]=='0') and (predF[x]=='1'), range(len(predG))))))
    c = float(len(list(filter(lambda x: (predG[x]=='1') and (predF[x]=='0'), range(len(predG))))))
    t = (b - c) ** 2 / (b + c)
    return t > 3.842
    </code></pre>
						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

				</section>

				<section>
					<section>
						<h2>Do it yourself</h2>

						<ul>
							<li>GA System</li>
							<li>La API</li>
							<li>Casos de uso</li>
						</ul>
						
						<aside class="notes">
							Just talk about what exactly we want to achieve
						</aside>
					</section>

					<section>
						<h2>GA System</h2>
						<p>
							El sistema que proponenmos es bastante sencillo de implementar.
						</p>
						<ul>
							<li>Componentes
								<ol>
									<li>Telemetría</li>
									<li>Processo de datos (Análisis)</li>
								</ol>
							</li>
							<li>Montado sobre OpenShift
								<ul>
									<li>Gratuíto para proyectos pequeños</li>
									<li>Muy asequible, unos 20$ al més, para proyectos grandes</li>
									<li>Todo en la cloud, sobre Amazon</li>
								</ul>
							</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/
						</aside>
					</section>

					<section>
						<h2>GA System</h2>
						<ul>
							<li>Implementado sobre Node.js
								<ul>
									<li>Performance increíble por usar Async I/O</li>
									<li>No es multi-thread! Menus consumo de RAM y CPU</li>
									<li>JavaScript mola!</li>
									<li>Package index igual que Python por ejemplo</li>
									<li>Jayson, JSON-RPC 2.0 package</li>
								</ul>
							</li>
							<li>Dos instancias de MongoDB
								<ul>
									<li>NoSQL es perfecto para este caso</li>
									<li>Rápido y flexible</li>
								</ul>
							</li>
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/
						</aside>
					</section>

					<section>
						<h2>GA System</h2>
						<p>
							<img src="img/GADiag.png" height="530px"/>
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/
						</aside>
					</section>

					<section>
						<h2>La API</h2>

						<ul>
							<li>Basado en sessiones, permite tener estadísticas simultáneas.</li>
							<li>La id de una sessión es simplemente la ID Encryptada de MongoDB</li>
							<li>Cada evento se submitea a una sessión existente</li>
							<li>Las sessiones han de tener una validez temporal, 24h por ejemplo
						</ul>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/
						</aside>
					</section>

					<section>
						<h2>La API</h2>

						<pre><code data-trim>
startSession: function(userid, platform, build, callback)
endSession: function(sessionid, callback)

addGamePlayEvent: function(sessionid, basedata, eventdata, callback)

addDebugEvent: function(sessionid, basedata, eventdata, callback)

addMonetaryEvent: function(sessionid, basedata, eventdata, callback)
    </code></pre>
					</section>

					<section>
						<h2>Casos de uso</h2>
						<h3>Progresión de niveles</h3>
						<p>
							Estamos trabajándo en un pequeño juego para plataformas móviles para el cual hemos implementatdo el sistema que os acabo de presentar.
						</p>
						<p>
							Los diseñadores de niveles han de tener claro como crear cada parte y necesitan datos detallados de como se comporta el jugador.
						</p>
						<p>
							Descubrimos que los primeros niveles son mucho más difíciles que los últimos.
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/
						</aside>
					</section>

					<section>
						<h2>Casos de uso</h2>
						<h3>Progresión de niveles</h3>
						<p>
							En qué nivel muere un jugador y más importante en que parte del nivel ha estado.
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/
						</aside>
					</section>

					<section>
						<h2>Casos de uso</h2>
						<h3>Progresión de niveles</h3>
						<p>
							Otro elemento importante es saber en cada nivel que ha pasado. Datos acomulados nos proporcionan mucha información al respecto: Balas usadas, recargas realizadas, pickups encontrados, vida perdida, etc...
						</p>
						<p>
							Aúnque a primera vista parecia que el número de pickups era suficiente los jugadores seguían muriéndo en nivel muy tempranos. La solución fue aumentar el número de pickups.
						</p>
						<p>
							Nos os puedo decir si ahora mismo hay suficientes ya que el juego que tenéis en el stand captura los eventos para ese fin! Así que si nos queréis hechar una mano jugad un poco!
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/
						</aside>
					</section>

					<section>
						<h2>Casos de uso</h2>
						<h3>Tracking de movimiento</h3>
						<p>
							Otro ejemplo muy útil es conocer el movimiento de los jugadores. El sistema de análisis DNA usado en la serie <b>Assassin's Creed</b> se inspira en <b>Google Maps</b> para representar movimientos de los jugadores
						</p>

						<p>
							Saber por dónde pasan los jugadores o incluso la IA nos indica muchas veces fallos en el diseño graves y muy difíciles de depurar en un estado tardío del desarollo.
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/

							http://engineroom.ubi.com/game-telemetry-with-playtest-dna-on-assassins-creed-part-3/
						</aside>
					</section>

					<section>
						<h2>Casos de uso</h2>
						<h3>Tracking de movimiento</h3>
						
						<p>
							<img src="img/assassins_1.jpg" width="300" height="200"/>
							<img src="img/assassins_2.jpg" width="300" height="200"/>
							<br/>
							<img src="img/assassins_3.png" height="200"/>
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/

							http://engineroom.ubi.com/game-telemetry-with-playtest-dna-on-assassins-creed-part-3/
						</aside>
					</section>

					<section>
						<h2>Casos de uso</h2>
						<h3>Heatmaps</h3>
						<p>
							Los heatmaps son otra visaulización fundamental de cualquier análisis, no sólo para juegos. En el mundo web o UI tenemos heatmaps de clicks para saber si los usarios encuentran las secciones, los banners son efectivos etc.
						</p>
						<p>
							En juegos se suelen general mapas de muertes o de kills pero es útil converger ambos en uno para poder visualizar bien lo que pasa en un mapa.
						</p>
						<p>
							Pero podemos incluso general heatmaps de consumo de memoria en ciertas partes de juego, de rendimiento, etc...
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/
						</aside>
					</section>

					<section>
						<h2>Casos de uso</h2>
						<h3>Heatmaps</h3>
						<p>
							El siguiente ejemplo nos muestra un mapa balanceado y un mapa de flujo del conjunto de muertes/deaths (el que muere y su asesino). El mapa balenceado es normalizado.
						</p>

						<p>
							<img src="img/NormalizedBalanceHeatmap.png" width="400"/>
							<img src="img/FlowMapThumbnail.jpg" width="400"/>
						</p>						

						<aside class="notes">
							Talk about what the balanced maps is and what the flow maps is. Flow mapss represent how the action goes over time.

							The balanced map has noise on the edges but thats because of the missing data.
						</aside>
					</section>

					<section>
						<h2>Casos de uso</h2>
						<h3>Matchmaking</h3>
						<p>
							Incluso los más modernos sistemas de matchmaking intentar generar grupos para crear partidas más divertidas o equilibradas.
						</p>

						<aside class="notes">
							http://www.doc.ic.ac.uk/~sgc/papers/ramirez_cgat10.pdf

							https://www.google.es/url?sa=t&rct=j&q=&esrc=s&source=web&cd=5&ved=0CFIQFjAE&url=http%3A%2F%2Fgdcvault.com%2Fplay%2F194%2FE-Pluribus-Unum-Matchmaking-in&ei=lILcUfaZO-7w0gWo4YEg&usg=AFQjCNHSlrauD-_wDELATqgMrG_KYUsMxg&sig2=jdDI7xxmwFDf8yyjaP0eQQ&cad=rja
						</aside>
					</section>

					<section>
						<h2>Casos de uso</h2>
						<h3>Matchmaking</h3>
						<p>
							Un ejemplo es el sistema de matchmaking de <b>Xbox Live</b> llamado <b>True Skill</b>.
						</p>
						<p>
							La idea es crear un ranking o score del jugador que va variando a medida que juega y despues crear grupos equilibrados de jugadores.
						</p>
						<p>
							Estimación bayesiana desarollado por <b>Microsoft Research Cambridge</b> 
						</p>

						<aside class="notes">
							http://www.doc.ic.ac.uk/~sgc/papers/ramirez_cgat10.pdf

							https://www.google.es/url?sa=t&rct=j&q=&esrc=s&source=web&cd=5&ved=0CFIQFjAE&url=http%3A%2F%2Fgdcvault.com%2Fplay%2F194%2FE-Pluribus-Unum-Matchmaking-in&ei=lILcUfaZO-7w0gWo4YEg&usg=AFQjCNHSlrauD-_wDELATqgMrG_KYUsMxg&sig2=jdDI7xxmwFDf8yyjaP0eQQ&cad=rja
						</aside>
					</section>

					<section>
						<h2>Casos de uso</h2>
						<h3>Matchmaking</h3>
						<p>
							Modela el skill del jugador como una función de densidad probabilistica [µ, σ]
							<ul>
								<li>µ es la media (estimada actual)</li>
								<li>σ es la desviación estándar (eincertidumbre)</li>
							</ul>
						</p>

						<p>
							<img src="img/true_skill1.png" width="400"/>
							<img src="img/true_skill2.png" width="400"/>
						</p>

						<aside class="notes">
							Just talk about what exactly we want to achieve

							http://www.altdevblogaday.com/2013/02/04/brewing-your-own-game-analytics-service/
						</aside>
					</section>
				</section>

				<section>
					<h1>Preguntas</h1>
				</section>

				<section>
					<h1>Grácias por esuchar</h1>
					<h2>Y no dormir a estas horas de la noche!</h2>
					<h3>Moritz Wundke</h3>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/search/search.js', async: true, condition: function() { return !!document.body.classList; } }
					// { src: 'plugin/remotes/remotes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
